'use client'

import { useState, useEffect, useCallback, useRef } from 'react'
import { Layout, Button } from '@/components'
import './snake-game.css'

// æ¸¸æˆé…ç½®
const GRID_SIZE = 20
const INITIAL_SNAKE = [{ x: 10, y: 10 }]
const INITIAL_FOOD = { x: 15, y: 15 }
const GAME_SPEED = 150

// æ–¹å‘æ§åˆ¶
const DIRECTIONS = {
  UP: { x: 0, y: -1 },
  DOWN: { x: 0, y: 1 },
  LEFT: { x: -1, y: 0 },
  RIGHT: { x: 1, y: 0 }
}

interface Position {
  x: number
  y: number
}

interface GameState {
  snake: Position[]
  food: Position
  direction: Position
  gameOver: boolean
  score: number
  isPlaying: boolean
  isPaused: boolean
}

export default function SnakeGamePage() {
  const [gameState, setGameState] = useState<GameState>({
    snake: INITIAL_SNAKE,
    food: INITIAL_FOOD,
    direction: DIRECTIONS.RIGHT,
    gameOver: false,
    score: 0,
    isPlaying: false,
    isPaused: false
  })

  const [gridSize, setGridSize] = useState(GRID_SIZE)
  const gameLoopRef = useRef<NodeJS.Timeout | null>(null)
  const touchStartRef = useRef<Position | null>(null)
  const gameBoardRef = useRef<HTMLDivElement>(null)

  // å“åº”å¼ç½‘æ ¼å¤§å°
  useEffect(() => {
    const updateGridSize = () => {
      const width = Math.min(window.innerWidth - 40, 600)
      const cellSize = Math.floor(width / GRID_SIZE)
      setGridSize(Math.floor(width / cellSize))
    }

    updateGridSize()
    window.addEventListener('resize', updateGridSize)
    return () => window.removeEventListener('resize', updateGridSize)
  }, [])

  // æ¸¸æˆå¾ªç¯
  useEffect(() => {
    if (!gameState.isPlaying || gameState.isPaused || gameState.gameOver) {
      if (gameLoopRef.current) {
        clearInterval(gameLoopRef.current)
        gameLoopRef.current = null
      }
      return
    }

  // ç§»åŠ¨è›‡
  const moveSnake = useCallback(() => {
    setGameState(prev => {
      const head = prev.snake[0]
      const newHead = {
        x: head.x + prev.direction.x,
        y: head.y + prev.direction.y
      }

      // æ£€æŸ¥è¾¹ç•Œç¢°æ’
      if (newHead.x < 0 || newHead.x >= GRID_SIZE || newHead.y < 0 || newHead.y >= GRID_SIZE) {
        return { ...prev, gameOver: true, isPlaying: false }
      }

      // æ£€æŸ¥è‡ªèº«ç¢°æ’
      if (prev.snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
        return { ...prev, gameOver: true, isPlaying: false }
      }

      const newSnake = [newHead, ...prev.snake]
      let newFood = prev.food
      let newScore = prev.score

      // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
      if (newHead.x === prev.food.x && newHead.y === prev.food.y) {
        newScore += 10
        // ç”Ÿæˆæ–°é£Ÿç‰©ï¼ˆç¡®ä¿ä¸åœ¨è›‡èº«ä¸Šï¼‰
        do {
          newFood = {
            x: Math.floor(Math.random() * GRID_SIZE),
            y: Math.floor(Math.random() * GRID_SIZE)
          }
        } while (newSnake.some(segment => segment.x === newFood.x && segment.y === newFood.y))
      } else {
        newSnake.pop()
      }

      return {
        ...prev,
        snake: newSnake,
        food: newFood,
        score: newScore
      }
    })
  }, [])
  // ç§»åŠ¨è›‡
  const moveSnake = useCallback(() => {
    setGameState(prev => {
      const head = prev.snake[0]
      const newHead = {
        x: head.x + prev.direction.x,
        y: head.y + prev.direction.y
      }

      // æ£€æŸ¥è¾¹ç•Œç¢°æ’
      if (newHead.x < 0 || newHead.x >= GRID_SIZE || newHead.y < 0 || newHead.y >= GRID_SIZE) {
        return { ...prev, gameOver: true, isPlaying: false }
      }

      // æ£€æŸ¥è‡ªèº«ç¢°æ’
      if (prev.snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
        return { ...prev, gameOver: true, isPlaying: false }
      }

      const newSnake = [newHead, ...prev.snake]
      let newFood = prev.food
      let newScore = prev.score

      // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
      if (newHead.x === prev.food.x && newHead.y === prev.food.y) {
        newScore += 10
        // ç”Ÿæˆæ–°é£Ÿç‰©ï¼ˆç¡®ä¿ä¸åœ¨è›‡èº«ä¸Šï¼‰
        do {
          newFood = {
            x: Math.floor(Math.random() * GRID_SIZE),
            y: Math.floor(Math.random() * GRID_SIZE)
          }
        } while (newSnake.some(segment => segment.x === newFood.x && segment.y === newFood.y))
      } else {
        newSnake.pop()
      }

      return {
        ...prev,
        snake: newSnake,
        food: newFood,
        score: newScore
      }
    })
  }, [])

  // é”®ç›˜æ§åˆ¶
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (!gameState.isPlaying || gameState.isPaused) return

      const key = e.key
      setGameState(prev => {
        let newDirection = prev.direction

        switch (key) {
          case 'ArrowUp':
          case 'w':
          case 'W':
            if (prev.direction.y === 0) newDirection = DIRECTIONS.UP
            break
          case 'ArrowDown':
          case 's':
          case 'S':
            if (prev.direction.y === 0) newDirection = DIRECTIONS.DOWN
            break
          case 'ArrowLeft':
          case 'a':
          case 'A':
            if (prev.direction.x === 0) newDirection = DIRECTIONS.LEFT
            break
          case 'ArrowRight':
          case 'd':
          case 'D':
            if (prev.direction.x === 0) newDirection = DIRECTIONS.RIGHT
            break
          case ' ':
            e.preventDefault()
            return { ...prev, isPaused: !prev.isPaused }
        }

        return { ...prev, direction: newDirection }
      })
    }

    window.addEventListener('keydown', handleKeyPress)
    return () => window.removeEventListener('keydown', handleKeyPress)
  }, [gameState.isPlaying, gameState.isPaused])

  // è§¦æ‘¸æ§åˆ¶
  const handleTouchStart = (e: React.TouchEvent) => {
    const touch = e.touches[0]
    touchStartRef.current = {
      x: touch.clientX,
      y: touch.clientY
    }
  }

  const handleTouchEnd = (e: React.TouchEvent) => {
    if (!touchStartRef.current || !gameState.isPlaying || gameState.isPaused) return

    const touch = e.changedTouches[0]
    const deltaX = touch.clientX - touchStartRef.current.x
    const deltaY = touch.clientY - touchStartRef.current.y
    const minSwipeDistance = 50

    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      // æ°´å¹³æ»‘åŠ¨
      if (Math.abs(deltaX) > minSwipeDistance) {
        setGameState(prev => {
          let newDirection = prev.direction
          if (deltaX > 0 && prev.direction.x === 0) {
            newDirection = DIRECTIONS.RIGHT
          } else if (deltaX < 0 && prev.direction.x === 0) {
            newDirection = DIRECTIONS.LEFT
          }
          return { ...prev, direction: newDirection }
        })
      }
    } else {
      // å‚ç›´æ»‘åŠ¨
      if (Math.abs(deltaY) > minSwipeDistance) {
        setGameState(prev => {
          let newDirection = prev.direction
          if (deltaY > 0 && prev.direction.y === 0) {
            newDirection = DIRECTIONS.DOWN
          } else if (deltaY < 0 && prev.direction.y === 0) {
            newDirection = DIRECTIONS.UP
          }
          return { ...prev, direction: newDirection }
        })
      }
    }

    touchStartRef.current = null
  }

  // æ¸¸æˆæ§åˆ¶å‡½æ•°
  const startGame = () => {
    setGameState({
      snake: INITIAL_SNAKE,
      food: INITIAL_FOOD,
      direction: DIRECTIONS.RIGHT,
      gameOver: false,
      score: 0,
      isPlaying: true,
      isPaused: false
    })
  }

  const pauseGame = () => {
    setGameState(prev => ({ ...prev, isPaused: !prev.isPaused }))
  }

  const resetGame = () => {
    setGameState({
      snake: INITIAL_SNAKE,
      food: INITIAL_FOOD,
      direction: DIRECTIONS.RIGHT,
      gameOver: false,
      score: 0,
      isPlaying: false,
      isPaused: false
    })
  }

  // æ¸²æŸ“æ¸¸æˆç½‘æ ¼
  const renderGrid = () => {
    const grid = []
    for (let y = 0; y < GRID_SIZE; y++) {
      for (let x = 0; x < GRID_SIZE; x++) {
        const isSnake = gameState.snake.some(segment => segment.x === x && segment.y === y)
        const isFood = gameState.food.x === x && gameState.food.y === y
        const isHead = gameState.snake[0].x === x && gameState.snake[0].y === y

        let cellClass = 'game-cell'
        if (isFood) cellClass += ' food'
        if (isSnake) {
          cellClass += isHead ? ' snake-head' : ' snake-body'
        }

        grid.push(
          <div
            key={`${x}-${y}`}
            className={cellClass}
            style={{
              width: `${100 / GRID_SIZE}%`,
              height: `${100 / GRID_SIZE}%`
            }}
          />
        )
      }
    }
    return grid
  }

  return (
    <Layout>
      <div className="min-h-screen bg-gradient-to-br from-green-100 via-blue-50 to-purple-50 flex items-center justify-center p-4">
        <div className="max-w-4xl mx-auto w-full">
          {/* Header */}
          <div className="text-center mb-8">
            <div className="text-6xl mb-4">ğŸ</div>
            <h1 className="text-4xl md:text-5xl font-bold text-gray-800 mb-4">
              è´ªåƒè›‡å¤§ä½œæˆ˜
            </h1>
            <p className="text-lg text-gray-600 mb-6">
              ä¸“ä¸ºæ‰‹æœºä¼˜åŒ–çš„ç»å…¸æ¸¸æˆ
            </p>
          </div>

          {/* Game Stats */}
          <div className="flex justify-center items-center space-x-6 mb-6">
            <div className="bg-white rounded-lg px-6 py-3 shadow-md">
              <div className="text-2xl font-bold text-blue-600">{gameState.score}</div>
              <div className="text-sm text-gray-600">åˆ†æ•°</div>
            </div>
            <div className="bg-white rounded-lg px-6 py-3 shadow-md">
              <div className="text-2xl font-bold text-green-600">{gameState.snake.length}</div>
              <div className="text-sm text-gray-600">é•¿åº¦</div>
            </div>
            <div className="bg-white rounded-lg px-6 py-3 shadow-md">
              <div className="text-2xl font-bold text-purple-600">
                {gameState.isPlaying ? (gameState.isPaused ? 'â¸ï¸' : 'â–¶ï¸') : 'â¹ï¸'}
              </div>
              <div className="text-sm text-gray-600">çŠ¶æ€</div>
            </div>
          </div>

          {/* Game Board */}
          <div className="flex justify-center mb-6">
            <div
              ref={gameBoardRef}
              className="game-board"
              style={{
                width: 'min(80vw, 400px)',
                height: 'min(80vw, 400px)',
                maxWidth: '400px',
                maxHeight: '400px'
              }}
              onTouchStart={handleTouchStart}
              onTouchEnd={handleTouchEnd}
            >
              {renderGrid()}
            </div>
          </div>

          {/* Game Controls */}
          <div className="flex flex-col items-center space-y-4">
            {/* Control Buttons */}
            <div className="flex space-x-4">
              {!gameState.isPlaying ? (
                <Button onClick={startGame} size="lg" variant="primary">
                  ğŸ® å¼€å§‹æ¸¸æˆ
                </Button>
              ) : (
                <>
                  <Button onClick={pauseGame} size="lg" variant="secondary">
                    {gameState.isPaused ? 'â–¶ï¸ ç»§ç»­' : 'â¸ï¸ æš‚åœ'}
                  </Button>
                  <Button onClick={resetGame} size="lg" variant="ghost">
                    ğŸ”„ é‡ç½®
                  </Button>
                </>
              )}
            </div>

            {/* Game Over */}
            {gameState.gameOver && (
              <div className="bg-red-100 border border-red-300 rounded-lg p-4 text-center">
                <h3 className="text-lg font-semibold text-red-800 mb-2">æ¸¸æˆç»“æŸï¼</h3>
                <p className="text-red-600 mb-2">æœ€ç»ˆåˆ†æ•°: {gameState.score}</p>
                <p className="text-red-600 text-sm">é•¿åº¦: {gameState.snake.length}</p>
              </div>
            )}

            {/* Instructions */}
            <div className="bg-white rounded-lg p-4 text-center max-w-md">
              <h4 className="font-semibold text-gray-800 mb-2">æ“ä½œè¯´æ˜</h4>
              <div className="text-sm text-gray-600 space-y-1">
                <p>ğŸ“± <strong>æ‰‹æœº:</strong> æ»‘åŠ¨å±å¹•æ§åˆ¶æ–¹å‘</p>
                <p>âŒ¨ï¸ <strong>ç”µè„‘:</strong> æ–¹å‘é”®æˆ–WASDç§»åŠ¨</p>
                <p>â¸ï¸ <strong>æš‚åœ:</strong> ç©ºæ ¼é”®æˆ–æš‚åœæŒ‰é’®</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </Layout>
  )
}